1) Linear Search Worst Case:-

The Worst case(s) occur in linear search algorithm when -

Options:-
Item is somewhere in the middle of the array
Item is the last element in the array <- 
Item is present at first index of the array.
Item is not in the array at all <-


2) Linear Search:-

The worst case time complexity of Linear search is :

Options
O(n) <-
O(n^2)
O(nlogn)
O(logn)

3) Worst Case Time Complexity of Insertion sort:-

Worst case time complexity of insertion sort is ?

Options
O(N)
O(N^2) <-
O(NLogN)
O(LogN)

4) Worst Case Time complexity of Selection Sort:-

Worst case time complexity of Selection sort is ?

Options
O(N)
O(N^2) <-
O(NLogN)
O(LogN)

5) Efficiency of an Algorithm:-

Two main measures for the efficiency of an algorithm are -

Options
Processor and memory
Complexity and capacity
Time and space <- 
Data and space

6) Theoretical Analysis:-

In theoretical analysis the time factor when determining the efficiency of algorithm is measured by -

Options
Counting microseconds
Counting the number of statements in code
Counting the number of unit operations  <- 
Counting the kilobytes of algorithm

7) Time Complexity:-

If the number of primary operations of an algorithm that takes an array of size n as input are 3n^2 + 5n. The worst case time complexity of the algorithm will be ?

Options
O(n^3)
O((n^2)*logn)
O(n^2) <- 
O(n)

8) Time Complexity of Code:-

What will be the Time Complexity of following code in terms of ‘n’ ?

Refer the code for C++ -
  for(int i = 0; i < n; i++){
    for(; i < n; i++){
        cout << i << endl;
    }
}

Options
O(n) <-
O(n^2)
O(logn)
O(nlogn)

9) Time Complexity of Code:-

What will be the Time Complexity of following code in terms of ‘n’ ?

Note : Assume k to be a constant value

Refer the code in C++ -
  for(int i = 0; i < n; i++){
     for(int j = 1 ; j < k; j++){
        cout << (i + j ) << endl;
      }
  }

Options
O(n^2)
O(n)  <-
O(logn)
None of these

10) Operations for merging

For merging two sorted arrays of size m and n into a sorted array of size m+n, we require operations -
Options
O(m * n)
O(m + n) <-
O(m) if m >= n
O(n) if n > m

11) Worst Case Time complexity of Binary Search

Worst case time complexity of Binary Search is ?

Options
O(N)
O(N^2)
O(NLogN) <-
O(LogN)

12) Recurrence for Merge Sort

What is the recurrence relation for merge sort :

Options
T(n) = 2T(n/2)
T(n) = 2T(n/2) + k
T(n) = 2T(n/2) + O(n)     <-
T(n) = 2T(n/2) + O(log n)

13) Merge sort

What is the time complexity of merge sort :

Options
O(n)
O(n^2)
O(nlogn) <- 
O(log n)

14) What is time complexity

What is the time complexity of following code ?
int multiplyRec(int m, int n){
    if(n == 1)
        return m;
    return m + multiplyRec(m,  n - 1);  
}

Options

O(m*n)
O(n)  <- 
O(n^2)
O(m)

15) What is time complexity

What is the time complexity of following code ?
int sumOfDigits(int n){
        int sum;
        if(n < 10){
            return n;
        }
        sum = (n % 10) + sumOfDigits(n / 10);
        return sum;
}

Options
O(logn) - log is to the base 10    <-
O(n)
O(n^2)
None of these

16) Fibonacci

What is the time complexity of following code for calculating nth fibonacci number
long fib(int n){
    if(n == 0 || n == 1){
         return n;
    }
    return fib(n - 1) + fib(n - 2);
}

Options
O(n)
O(n^2)
O(2^n)  <- 
O(n^3)

17) Merge Sort space

The space complexity for merge sort is :

Options
O(n)     <-
O(n^2)
O(nlogn)
O(log n)

18) Fibonacci

The space complexity for finding nth fibonacci number using recursion is :

Options
O(n)    <-
O(2^n)
O(log n)
O(n^2)
O(nlogn)



